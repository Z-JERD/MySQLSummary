# MySQL锁机制
## 参考文档： https://juejin.im/post/5b82e0196fb9a019f47d1823  https://mp.weixin.qq.com/s/WgcLdEfjFE3CsWV4FgOefw

# 锁的级别

    MyISAM存储主要就简单的表级别锁
    
    InnoDB不仅支持行级别的锁，也支持表级别的锁, 默认为行级锁

## 1. 表级锁：
    
    开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。
    
    锁的是整张表，限制的是整张表的数据读写。
    
## 2. 行级锁：
    
    开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
    
    锁的是表中对应的行，只限制当前行的读写

## 3. 页面锁：
    
    开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
    
    锁的是整张表中某页数据，限制的是某页的数据读写。
    

# 乐观锁和悲观锁

    乐观锁和悲观锁是泛指，不是具体的锁。
    
    表锁和行锁也是泛指，不是具体的锁
    
## 1. 乐悲锁
    
    乐观并发控制，它总是乐观的认为用户在并发事务处理时不会影响彼此的数据。
    
### 乐观锁的实现：    
    
    用数据版本（Version）记录机制实现，即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。
    当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。当我们提交更新的时候，
    判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等
    ，则予以更新，否则认为是过期数据
    
    每次更新表中的value字段时，为了防止发生冲突，需要这样操作
        update TABLE  set value=xx,version=version+1  where id=id and version=version


    
## 2. 悲观锁

    认为每次去拿的数据都会被别人修改。所以每次在拿数据的时候都会上锁，从而屏蔽可能违反数据完整性的操作。
    
    悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。
    
    间隙锁、临键锁都属于悲观锁。



# 共享锁(S锁)和排他锁(X锁)
    
    InnoDB引擎实现了标准的行级别锁：分别是共享锁和排他锁。

    拿共享锁是为了让当前事务去读一行数据。
    
    拿排他锁是为了让当前事务去修改或删除某一行数据。
    
    一个事务拿到了当前数据行的共享锁，另一个事务也能马上拿到当前数据行的共享锁。

    一个事务拿到了当前数据行的排他锁，则另一个事务不能立马拿到当前数据行的排他锁，因为它会被阻塞直到前一个事务释放。
    
    设置共享锁：select * from user where id = 1 LOCK IN SHARE MODE;
    
    设置排他锁：select * from user where id = 1 FOR UPDATE;


  
# 表锁和行锁
    
   
    
## 表锁具体的锁种类：
    
    意向共享锁、意向排他锁、自增锁等


## 行锁具体的锁种类：

    InnoDB的行锁都是实现在索引上的。

    共享锁、排他锁、记录锁
