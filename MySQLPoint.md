 # 主键相关
 ## 为什么一定要设一个主键？
    
    不设主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。所以啦，反正都要生成一个主键，那你还不如自己指定一个主键，
    在有些情况下，就能显式的用上主键索引，提高查询效率！
    
## 主键是用自增还是UUID
    
    用自增插入性能好！如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，
    当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片
    
## 自增主键达到最大值了，用完了怎么办
    
    Int整型,无符号整型为例，存储范围约43亿,一旦自增id达到最大值，此时数据继续插入是会报一个主键冲突异常
    解决方法: 将Int类型改为BigInt类型
    
    专业做法：分库分表
        表中真实的数据ID，肯定会出现一些意外，ID不一定是连续的，自增主键id的数据范围为0～2147483648，也就是单表21亿条数据！
        考虑id会出现断续，真实数据顶多18亿条吧。还不分库分表？一旦分库分表了，就不能依赖于每个表的自增ID来全局唯一标识这些数据了。
        此时，我们就需要提供一 个全局唯一的ID号生成策略来支持分库分表的环境
        
## 主键为什么不推荐有业务含义?
    (1)因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，
       该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。
    (2)带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。
       如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片
    
# 字段类型相关
## 表示枚举的字段为什么不用enum类型      
     
     在工作中表示枚举的字段，一般用tinyint类型
     ENUM类型的ORDER BY操作效率低，后期维护不方便
     
## 货币字段用什么类型?
    
    如果货币单位是分，可以用Int类型。如果坚持用元，用Decimal。
    float和double是以二进制存储的，所以有一定的误差
    
## 时间字段用什么类型?
    
    1.timestamp
        该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。
        2038年以后的时间，是无法用timestamp类型存储的。 但是它有一个优势，timestamp类型是带有时区信息的。
        一旦你系统中的时区发生改变，例如你修改了时区
        
        SET TIME_ZONE = "america/new_york";
        你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！
    
    2.datetime
        datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。
        但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！
        
## 为什么不直接存储图片、音频、视频等大容量内容?
    
    在实际应用中，都是用HDFS来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，
    也就是text和blob类型。在生产中，基本不用这两个类型！
    
## 字段为什么要定义为NOT NULL
    Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。
    可空列被索引后，每条记录都需要一个额外的字节
    
  
# 为什么不推荐使用外键约束
    很多人在工作中确实也不会使用外键。包括在阿里的JAVA规范中也有下面这一条
    【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 
    
    但是呢，询问他们原因，大多是这么回答的:
        每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便。
        
    1.性能问题
        
        假设一张表名为user_tb。那么这张表里有两个外键字段，指向两张表。那么，每次往user_tb表里插入数据，
        就必须往两个外键对应的表里查询是否有对应数据。如果交由程序控制，这种查询过程就可以控制在我们手里，
        可以省略一些不必要的查询过程。但是如果由数据库控制，则是必须要去这两张表里判断。
    
    2.并发问题
        在使用外键的情况下，每次修改数据都需要去另外一个表检查数据,需要获取额外的锁。若是在高并发大流量事务场景，使用外键更容易造成死锁。
        
    
    3.技术问题
        使用外键，其实将应用程序应该执行的判断逻辑转移到了数据库上。那么这意味着一点，数据库的性能开销变大了，
        相反的，如果该约束逻辑在应用程序中，发现应用服务器性能不够，可以加机器，做水平扩展。如果是在数据库服务器上，
        数据库服务器会成为性能瓶颈，做水平扩展比较困难
# 在线上怎么修改列的数据类型的？
    
    由于mysql在线ddl(加字段、加索引等修改表结构之类的操作）过程如下：
        A.对表加锁(加了个排它锁，这个时候其他用户只能读表的数据,不能写)
        B.复制原表物理结构
        C.修改表的物理结构
        D.把原表数据导入中间表中，数据同步完后，锁定中间表，并删除原表
        E.rename中间表为原表
        F.刷新数据字典，并释放锁
        
       
    在这个过程中会锁表。造成当前操作的表无法写入数据，影响用户使用。由于需要复制原表的数据到中间表，所以表的数据量越大，等待的时候越长，卡死在那里(用户被拒绝执行update和insert操作,表现就是延迟了一直在等待)
    平时进行修改表的结构，更改字段，新增字段，更改字段名称一般都是通过ALTER TABLE  TABLENAE 语法进行修改的。
    对于测试库，在线小表或者并发访问不是很大的情况是OK。但是如果是在线大表。那就很麻烦。由于表数据量大，复制表需要比较长的时间，
    在这个时间段里面，表是被加了锁的(写锁)，加写锁时其他用户只能select表不能update、insert表。表数据量越大，耗时越长
        
        
    1. mysql5.6+提供的在线修改功能
        
        mysql> ALTER TABLE table_name CHANGE old_field_name new_field_name field_type;
        在5.6+开始，mysql支持在线修改数据库表，在修改表的过程中，对绝大部分操作，原表可读，也可以写
        对于修改列的数据类型这种操作，ALTER这样的语句在线修改表数据结构，会导致这张表无法进行更新类操作(DELETE、UPDATE、DELETE)。
    
    2.借助第三方工具
        在执行ALTER操作的时候，表不会阻塞！比较出名的有两个
        pt-online-schema-change，简称pt-osc
        GitHub正式宣布以开源的方式发布的工具，名为gh-ost
    
        工作原理：以pt-osc为例，它的原理如下

            1、创建一个新的表，表结构为修改后的数据表，用于从源数据表向新表中导入数据。
            
            2、创建触发器，用于记录从拷贝数据开始之后，对源数据表继续进行数据修改的操作记录下来，用于数据拷贝结束后，执行这些操作，保证数据不会丢失。
            
            3、拷贝数据，从源数据表中拷贝数据到新表中。
            
            4、rename源数据表为old表，把新表rename为源表名，并将old表删除。
            
            5、删除触发器
            
        BUG：
            如果表里有触发器和外键，这两个工具是不行
            
    3.改从库表结构，然后主从切换
        mysql架构一般是读写分离架构，从机是用来读的。我们直接在从库上进行表结构修改，不会阻塞从库的读操作。
        改完之后，进行主从切换即可。唯一需要注意的是，主从切换过程中可能会有数据丢失的情况！
          
 
# 事务相关
## 参考文档：https://zhuanlan.zhihu.com/p/59061106

## mysql有几个事务隔离级别？
    
    读未提交，读已提交，可重复读，串行化四个！
    默认是可重复读
    
## 为什么mysql选可重复读作为默认的隔离级别？

    为了保证主从复制不出问题
    
    Mysql在5.0这个版本以前，binlog只支持STATEMENT这种格式！而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，
    因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别
    
    在master上执行的顺序操作为先删后插！而此时binlog为STATEMENT格式，它记录的顺序为先插后删！从(slave)同步的是binglog，因此
    从机执行的顺序和主机不一致！就会出现主从不一致！
    
### 如何解决主从不一致问题？
        
        1. 隔离级别设为可重复读(Repeatable Read), 在该隔离级别下引入间隙锁。当Session 1执行delete语句时，会锁住间隙。
            那么,执行插入语句就会阻塞住！ 
        2. 将binglog的格式修改为row格式，此时是基于行的复制，自然就不会出现sql执行顺序不一样的问题！
            这个格式在mysql5.1版本开始才引入。因此由于历史原因，mysql将默认的隔离级别设为可重复读(Repeatable Read)，
            保证主从复制不出问题！

## 项目中选了哪个隔离级别？为什么？
    选择：读已提交
    
    可重复读(Repeatable Read)，简称为RR； - 读已提交(Read Commited)，简称为RC；
    
    1. 在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！
        
        在RR隔离级别下，存在间隙锁，防止其他事务插入数据！ 而在RC隔离级别下，不存在间隙锁，其他事务是可以插入数据！
        在RC隔离级别下并不是不会出现死锁，只是出现几率比RR低而已！
        
    2. 在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行 
        在RC隔离级别下，其先走聚簇索引，进行全部扫描， 在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁
        在RR隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上
    
## 项目中为什么不用读未提交和串行化两个隔离级别？
    
    采用读未提交(Read UnCommitted)：
        一个事务读到另一个事务未提交读数据，从逻辑上都说不过去
        
    采用串行化(Serializable)：
        读取的每一行数据上都加锁，快照读失效， 所以可能导致大量的超时和锁争用的问题,因此并发度急剧下降
        一般是使用mysql自带分布式事务功能时才使用该隔离级别
        
## 在RC级别下，不可重复读问题需要解决么？
    
    不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！
    
## 在RC级别下，主从复制用什么binlog格式？
    
    该隔离级别下，用的binlog为row格式，是基于行的复制！

## Mysql怎么保证一致性的？ 
    
    1.从数据库层面：
        数据库通过原子性、隔离性、持久性来保证一致性。
    
    2. 从应用层面:
        通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！
    
## Mysql怎么保证原子性的？
    
    利用Innodb的undo log。 undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，
    
    他需要记录你要回滚的相应日志信息。 例如 
    
    (1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据  
    
    (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作 
    
    (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作
    
    undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
    
## Mysql怎么保证持久性的？
    
    利用Innodb的redo log
    采用redo log当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当数据库宕机重启的时候，
    会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。
    
    
## Mysql怎么保证隔离性的？
   
    利用的是锁和MVCC机制
    MVCC,即多版本并发控制,一个行记录数据有多个版本对快照数据，
    这些快照数据在undo log中。 如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本
   
# 索引 
## 参考文档：https://zhuanlan.zhihu.com/p/89935484
## 开启慢日志查询
    
    慢日志作用:
        将影响数据库性能的sql语句记录到日志文件,通过对这些sql语句分析改进来提高数据库的性能
	
	1.查看慢查询相关参数：
		show variables like 'slow_query%'
	2.将 slow_query_log 全局变量设置为“ON”状态
	3.设置慢查询日志存放的位置
	4.设置记录时间
		set global long_query_time=1;
	
	永久生效修改配置文件：/etc/my.cnf
        [mysqld]
        slow_query_log = ON
        slow_query_log_file = /var/lib/mysql/test-10-226-slow.log
        long_query_time = 1
        
## 索引的原理: https://zhuanlan.zhihu.com/p/62018452
    
    索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据。
    索引的原理是不断地缩小想要获取数据的范围,同时把无序的数据变成有序的查询
		
    1. 把创建了索引的列的内容进行排序
    2. 对排序结果生成倒排表
    3. 在倒排表内容上拼上数据地址链
    4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据
    
## 索引的优点和缺点
    
    优点：
        · 加快检索速度
		· 唯一索引确保每行数据的唯一性
		· 在使用索引的过程可以优化隐藏器，提高系统性能
    
    缺点：
        · 创建索引时需要花费一定的时间
        · 插入 删除 修改 维护速度下降
		· 占用物理和数据空间
        
## 建立索引的规则
    
    1. 索引并非越多越好，大量的索引不仅占用磁盘空间，而且还会影响insert,delete,update等语句的性能
    
    2. 避免对经常更新的表做更多的索引，并且索引中的列尽可能少；

    3. 数据量少的表尽量不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果
    
    4. 在经常用到不同值较多的列上创建索引，在不同值很少的列上不要建立索引。比如性别字段只有“男”“女”俩个值，
       就无需建立索引。如果建立了索引不但不会提升效率，反而严重减低数据的更新速度

    5. 在频繁进行排序或者分组的列上建立索引，如果排序的列有多个，可以在这些列上建立联合索引
    
    6. 对于一些特殊的数据类型，不要建立索引
            如文本字段(TXT)、图像类型字段(IMAGE)
            这些字段的长度不确定,建立索引,那根本起不了作用
            
    7. 尽量选择区分度高的列作为索引
    
## 如何创建建索引
    
    1. 去my.cnf里配置慢查询日志
    
    2. 根据建立索引的规则创建
    
## 索引的种类
    
    1. 从物理存储角度:
        
        聚簇索引(聚集索引)和非聚簇索引(辅助索引)
    
    2. 从数据结构角度:
        
        B+树索引、hash索引、FULLTEXT索引、R-Tree索引

    3.从逻辑角度:

        主键索引：  主键索引是一种特殊的唯一索引，不允许有空值
        唯一索引:   加速索引和唯一约束,索引列的值必须唯一，但允许有空值
        普通索引:   加速查询,它没有任何限制,直接在某个字段加上索引就可以了
        组合索引：  将n个列组合成一个索引,列值的组合必须唯一,创建方法和普通索引类似
                   遵循循最左前缀匹配, 当遇到范围查询(>、<、between、like)就会停止匹配。

## B+ Tree的叶子节点都可以存哪些东西?
    InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值
    
    在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。
    而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引。

## 聚簇索引和非聚簇索引的区别
    
    聚簇索引:
        按照每张表的主键来构造一颗B+树，叶子节点存放的就是整张表的行数据,一张表只能有一个聚簇索引
        在Innodb中，聚簇索引默认就是主键索引
        
        没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引
        如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引
    
    非聚簇索引:
        
        如组合索引、普通索引、唯一索引 都是属于非聚簇索引, 叶子节点存储了主键的值
        
	相同点：
        
        两者内部都是B+tree形式,高度是平衡的,叶子节点存放着所有的数据
	
	不同点：
		
		1. 簇索引的叶子节点存放着一整行的信息,每张表只有一个聚集索引
		2. 非聚簇索引的叶子节点存放着单个索引列信息,通过叶子节点上的书签连接 再去找相应的行数据
	
	何时使用聚集索引或非聚集索引：
		1.列经常被分组排序,存在外键列和主键列
		2.返回某范围内的数据应使用聚集索引
		3.频繁的更新列和修改索引列应使用非聚集索引
		4.返回一个或极少不同值时都不用
			             
## 什么是B-树？ https://mp.weixin.qq.com/s/rDCEFzoKHIjyHfI_bsz5Rw
    B树又可以写成B-树/B-Tree
    
## 什么是B+树？ https://mp.weixin.qq.com/s/jRZMMONW3QP43dsDKIV9VQ
## mysql索引为什么不用红黑树或者 B tree
    
    红黑树：
        红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据数据存储的时候，显然不能将全部数据全部加载进内存，
        因此如果采用红黑树，就会造成频繁IO，效率低下	
      
    B tree的两个明显特点：
        1. 叶子节点还是非叶子节点，都会保存数据
        2. 叶子节点上无链表
        
        
    B+ tree的两个明显特点：
        数据只出现在叶子节点
        所有叶子节点增加了一个链指针
    
    数据库索引采用B+ tree的主要原因:
        B-Tree在非叶子节点中能保存的指针数量变少,指针少的情况下要保存大量数据，只能增加树的高度，
        导致IO操作变多，查询性能变低；
 
        B+ tree只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，
        如果使用B Tree，则需要做局部的中序遍历，可能要跨层访问，效率太慢

        

## 主键和唯一索引的区别：
    
    1.  主键既是约束也是索引，唯一索引是一种索引，是表的冗余数据结构
    
    2.  一张表只能有一个主键，但可以创建多个唯一索引；
    
    3.  主键创建后一定会创建一个唯一索引，但是有唯一索引的列并不一定是主键；
    
    4.  主键不能为null，唯一索引可以为null；
    
    5.  主键可以做为一个表的外键，唯一索引不行；
    
## 为什么唯一索引的插入速度比不上普通索引？
    在进行非聚簇索引的插入时，先判断插入的索引页是否在内存中。如果在，则直接插入；如果不在，则先放入Insert Buffer 中，
    然后再以一定频率和情况进行Insert Buffer和原数据页合并(merge)操作
    
    这么做的优点:
        
        1. 能将多个插入合并到一个操作中，就大大提高了非聚簇索引的插入性能。
        2. 减少磁盘的离散读取
        
    使用 Insert Buffer 得满足两个条件：
    
        索引是辅助索引
        索引不是唯一
        
    InnoDB 从 1.0.x 版本开始引入了 Change Buffer，可以算是对 Insert Buffer 的升级。
    从这个版本开始，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。
    
    使用 Change Buffer 得满足两个条件：
        索引是辅助索引
        索引不是唯一
    
    唯一索引的插入比普通索引慢的原因就是:
        唯一索引无法利用Change Buffer
        普通索引可以利用Change Buffer
     
    为什么唯一索引的更新不使用 Change Buffer？
        唯一索引为了保证唯一性，需要将数据页加载进内存才能判断是否违反唯一性约束。
        但是，既然数据页都加载到内存了，还不如直接更新内存中的数据页，没有必要再使用Change Buffer
        
## 唯一索引的搜索速度比普通索引快的原因?
    
    普通索引在找到满足条件的第一条记录后，还需要判断下一条记录，直到第一个不满足条件的记录出现。
    
    唯一索引在找到满足条件的第一条记录后，直接返回，不用判断下一条记录了

    
## 什么是覆盖索引和如何避免回表查询
    
    覆盖索引：
        
        如果索引的叶子节点包含了要查询的数据，那么就不用回表查询了。这种索引为覆盖索引,覆盖索引就是从索引中直接获取查询结果
	    条件：
	        select查询列中包含在索引列中
    
    回表查询：
        
        通过非聚簇索引先定位主键值，再定位行记录
        
    通过读取索引就可以得到想要的数据，就不需要回表读取
    
    例如此时有一张表table1,有一个联合索引(a,b) 执行如下SQL

        select a,b from table1
        
        在索引上就能找到结果，就不用回表去查询！

    而如果执行的是

        select a,b,c from table2
        
        c列在索引上不存在，就需要回表查询
        
    覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以mysql只能用B+ tree索引做覆盖索引
 
## mysql某表建了多个单索引，查询多个条件时如何走索引的？
    
    明明创建了索引，但是执行的时候并没有通过索引呢？
    
    mysql在优化器中有一个优化器称为Range 优化器，负责进行范围查询的优化！
    mysql会对每种索引的执行情况，进行上述成本计算，最后以成本小的方式进行执行
    
    计算出的数值将会作为mysql优化器对语句执行计划进行判定时依据。如果唯一性太小，那么优化器会认为，这个索引对语句没有太大帮助，
    而不使用索引。Cardinality值越大，就意味着，使用索引能排除越多的数据，执行也更为高效。
    
## MySQL 5.6中，对索引做了哪些优化?
    
    MySQL 5.6引入了索引下推优化，默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。
    
    官方文档中给的例子和解释如下： 
        
        people表中（zipcode，lastname，firstname）构成一个索引
        SELECT * FROM people WHERE zipcode=‘95054’ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;
        
        如果没有使用索引下推技术:
            则MySQL会通过zipcode='95054’从存储引擎中查询对应的数据，返回到MySQL服务端，
            然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。 
        
        如果使用了索引下推技术:
            则MYSQL首先会返回符合zipcode='95054’的索引，然后根据lastname LIKE '%etrunia%'
            和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，
            则直接reject掉。 有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。
 
## 索引的数据结构
    索引是一种数据结构。索引本身很大，不可能全部存储在内存中，因此索引以索引表的形式存储在磁盘中。这样的话，索引查找过程中
    就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，因此索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数
    
    数据库索引为什么要用树结构做存储？
    树的查询效率高，还可以做有序。
   
## B+TREE索引：查询时间大概是O(logn)
    B+树的优势：
        1. 叶子节点上存放了所有的数据，并且有指针相连，构成双向循环链表。
           非子叶节点（根节点、枝节点）只存放键值，不存放实际数据。所以对于范围查找比较友好
           
        2. 查询效率稳定
            B+树的所有数据都在叶子节点上，所以B+树的，通常其高度都在2~3层，一般都是查询3次, 查询时可以有效减少IO次数
        
        3. B+树有利于数据库的扫描。
        
        4. B+树有利于磁盘的IO
            层高基本不会因为数据扩大而增高（三层树结构大概可以存放两千万数据量)。
            
            系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一磁盘块中的数据会被一次性读取出来，而不是按需读取
    
    b+树的查找过程：
        
        1.如果要查找数据项30，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，
        
        2.在内存中用二分查找确定30在28和65之间，锁定磁盘块1的P2指针,通过磁盘块1的P2指针的磁盘地址把磁盘块由磁盘加载到内存，发生第二次IO，
       
        3.30在28和35之间，锁定当前磁盘块的P1指针，通过指针加载磁盘块到内存，发生第三次IO，同时内存中做二分查找找到30，结束查询，总计三次IO
		
### HASH索引:查询时间大概是O(1)
    
    哈希索引就是采用一定的哈希算法, 把键值换算成新的哈希值,只需一次哈希算法即可立刻定位到相应的位置，速度非常快
    Hash 索引的效率要比 B-Tree 高很多, 但有很多限制和弊端
    
    弊端：
        
        1. Hash索引只支持等值比较，例如使用=，IN( )和<=>  对于WHERE price>100并不能加速查
            Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤
            经过过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样
        
        2. Hash 索引无法进行排序操作
            Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，
            所以数据库无法进行排序运算；
        
        3. Hash 索引不支持多列联合索引的最左匹配规则
             对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，
             所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用
             
        4. Hash索引在任何时候都不能避免表扫描(哈希碰撞问题)
            Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，
            由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，
            还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果
		
### HASH与BTREE比较：
    
    hash类型的索引：查询单条快，范围查询慢
    
    btree类型的索引：b+树，层数越多，数据量越大,范围查询和随机查询快（innodb默认索引类型）
    
### MySQL数据库为何要用B+树存储索引：
    
    这和业务场景有关。如果只选一个数据，那确实是hash更快。但是数据库中经常会选择多条，
    这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。而且数据库中的索引一般是在磁盘上，
    数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载


# Limit SQL查询优化
## 参考文档： https://zhuanlan.zhihu.com/p/125090908
## 优化方法
    
    优化前SQL：
        SELECT  各种字段 FROM `table_name` WHERE 各种条件  LIMIT 0, 10;
        
    优化后SQL：
        SELECT  各种字段 FROM`table_name` main_tale RIGHTJOIN ( SELECT  子查询只查主键 FROM `table_name` WHERE 各种条件  
        LIMIT0, 10 ) temp_table ON temp_table.主键 = main_table.主键
        
    
    操作： 查询条件放到子查询中, 子查询只查主键ID, 然后使用子查询中确定的主键关联查询其他的属性字段；
    原理： 减少回表操作
    

## MySQL 用 limit 为什么会影响性能
    
    limit offset rows中的offset很大时，会出现效率问题
    test 表中id为自增主键，val为非唯一索引, 数据量500W
    
    
    mysql> select * fromtestwhere val=4 limit 300000,5;
        +---------+-----+--------+
        | id      | val | source |
        +---------+-----+--------+
        | 3327622 |   4 |      4 |
        | 3327632 |   4 |      4 |
        | 3327642 |   4 |      4 |
        | 3327652 |   4 |      4 |
        | 3327662 |   4 |      4 |
        +---------+-----+--------+
        5 rows in set (15.98 sec)
    
    优化：
        mysql> select * from test a inner join (select id from test where val=4 limit 300000,5) b on a.id=b.id;
            +---------+-----+--------+---------+
            | id      | val | source | id      |
            +---------+-----+--------+---------+
            | 3327622 |   4 |      4 | 3327622 |
            | 3327632 |   4 |      4 | 3327632 |
            | 3327642 |   4 |      4 | 3327642 |
            | 3327652 |   4 |      4 | 3327652 |
            | 3327662 |   4 |      4 | 3327662 |
            +---------+-----+--------+---------+
            5 rows in set (0.38 sec)   
    
### select * limit 查询过程
    
    查询到索引叶子节点数据。根据叶子节点上的主键值去聚簇索引上查询需要的全部字段值
    
    类似于下面这张图：
         ![avatar](https://pic1.zhimg.com/80/v2-af197a6c20a0232e590a9cba22dea5ac_1440w.jpg)
    
    像上面这样，需要查询300005次索引节点，查询300005次聚簇索引的数据，最后再将结果过滤掉前300000条，取出最后5条。
    MySQL耗费了大量随机I/O在查询聚簇索引的数据上，而有300000次随机I/O查询到的数据是不会出现在结果集当中的
    
### 优化后查询过程
    
    先沿着索引叶子节点查询到最后需要的5个节点，然后再去聚簇索引中查询实际数据。这样只需要5次随机I/O
    
    类似于下面这张图：
        ![avatar](https://pic3.zhimg.com/80/v2-787abf42e426d9f084a2a21d265cbb12_1440w.jpg)
